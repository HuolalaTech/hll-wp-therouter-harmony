"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Report = void 0;
const path = require("path");
const fs = require("fs");
const log4js = require("log4js");
const html_1 = require("./html");
const coverage_1 = require("../coverage");
const logger = log4js.getLogger();
const Object2ArrayKeys = new Set(['functions', 'regions', 'branches', 'group']);
const PATTERN_ANONYMOUS_FUNCTION = /^anonymous_\d+$/;
const ANONYMOUS = 'anonymous_';
function calcRegionLine(funcMap, funcName, exeLineArr, i, executedLineCount, region) {
    if (exeLineArr.indexOf(i) === -1 || executedLineCount[i] === -2) {
        // 无需计算
        return;
    }
    if (region.ignored !== coverage_1.IgnoreType.None) {
        // ignore场景
        executedLineCount[i] = -2;
        return;
    }
    if (region.startLoc.line === region.endLoc.line) {
        // get set 同名函数，同一行
        let functionName = i + '#' + funcName;
        if (funcName.match(PATTERN_ANONYMOUS_FUNCTION)) {
            functionName = i + '#' + ANONYMOUS;
        }
        setExecutedLineCount(funcMap, functionName, region, executedLineCount, i);
    }
    else if (funcName.match(PATTERN_ANONYMOUS_FUNCTION)) {
        // 匿名函数
        let functionName = i + '#' + ANONYMOUS + '#'
            + region.startLoc.line + region.endLoc.line + region.endLoc.col;
        setExecutedLineCount(funcMap, functionName, region, executedLineCount, i);
    }
    else {
        executedLineCount[i] = region.count;
    }
}
function setExecutedLineCount(funcMap, functionName, region, executedLineCount, i) {
    if (!funcMap.has(functionName)) {
        funcMap.set(functionName, region.count);
    }
    let tempCount = funcMap.get(functionName);
    executedLineCount[i] = Math.max(region.count, tempCount ? tempCount : 0);
    funcMap.set(functionName, executedLineCount[i]);
}
class Report {
    constructor(covFile) {
        this.covFile = covFile;
    }
    generateReport(projectPath) {
        this.coverage = new coverage_1.CoverageReport();
        let coverageData = JSON.parse(fs.readFileSync(this.covFile, 'utf-8'), (key, value) => {
            // Object to Array
            if (Object2ArrayKeys.has(key)) {
                return Object.values(value);
            }
            return value;
        });
        for (const file of Object.values(coverageData)) {
            let fileData = file;
            if (!fileData.version) {
                continue;
            }
            if (fileData.summary == undefined) {
                fileData.summary = new coverage_1.Summary();
            }
            fileData.path = fileData.path.replace(fileData.projectPath ? fileData.projectPath : '', projectPath);
            this.coverage.files.push(fileData);
        }
        // calculate the coverage
        this.calcFunctionCoverage();
        this.calcLineCoverage();
        this.calcBranchCoverage();
        // summy coverageMapData
        this.calculateSummary();
        return this.coverage;
    }
    writeReport(projectPath, output) {
        if (!this.coverage) {
            this.generateReport(projectPath);
        }
        this.output = output;
        if (output == undefined) {
            this.output = path.resolve('.bjc');
        }
        fs.mkdirSync(this.output, { recursive: true });
        this.writeJsonReport();
        this.writeHtmlReport();
    }
    calculateSummary() {
        var _a;
        (_a = this.coverage) === null || _a === void 0 ? void 0 : _a.summary.update();
    }
    calcFunctionCoverage() {
        for (const fileData of this.coverage.files) {
            if (!fileData.functions) {
                continue;
            }
            let { totalFunctions, executedFunctions } = this.doCalcFunction(fileData);
            fileData.summary.functions = new coverage_1.Coverage(totalFunctions, executedFunctions);
            this.coverage.summary.functions.total += totalFunctions;
            this.coverage.summary.functions.covered += executedFunctions;
        }
    }
    doCalcFunction(fileData) {
        let totalFunctions = 0;
        let executedFunctions = 0;
        fileData.functions.forEach((functionItem) => {
            if (functionItem.ignored === coverage_1.IgnoreType.None) {
                totalFunctions++;
                if (functionItem.count > 0) {
                    executedFunctions++;
                }
            }
        });
        return { totalFunctions, executedFunctions };
    }
    calcFileLineCoverage(file) {
        if (!file.exeLine) {
            return;
        }
        let executedLineCount = [];
        const exeLineArr = Object.values(file.exeLine);
        // start line 1
        for (let i = 0; i < file.lineCnt + 1; i++) {
            executedLineCount[i] = -1;
        }
        // set executed line count
        let functionNameMap = new Map();
        for (const func of file.functions) {
            func.regions.sort((a, b) => {
                return a.startLoc.line - a.endLoc.line - (b.startLoc.line - b.endLoc.line);
            });
            for (const region of func.regions) {
                for (let i = region.startLoc.line; i <= region.endLoc.line; i++) {
                    calcRegionLine(functionNameMap, func.name, exeLineArr, i, executedLineCount, region);
                }
            }
            this.caleFileLineInBranches(func, executedLineCount);
        }
        functionNameMap.clear;
        let totalLines = 0;
        let executedLines = 0;
        // Count valid lines of code
        for (let cnt of executedLineCount) {
            if (cnt >= 0) {
                totalLines++;
            }
            if (cnt >= 1) {
                executedLines++;
            }
        }
        let lineCoverage = new coverage_1.Coverage(totalLines, executedLines);
        lineCoverage.executedLineCount = executedLineCount;
        file.summary.lines = lineCoverage;
        this.coverage.summary.lines.total += totalLines;
        this.coverage.summary.lines.covered += executedLines;
    }
    caleFileLineInBranches(func, executedLineCount) {
        for (const branch of func.branches) {
            for (let i = branch.startLoc.line; i <= branch.endLoc.line; i++) {
                if (executedLineCount[i] === -2) {
                    continue;
                }
                if (branch.ignored == coverage_1.IgnoreType.None || branch.ignored == coverage_1.IgnoreType.Else) {
                    executedLineCount[i] = branch.trueCount + branch.falseCount;
                }
                else if (branch.ignored == coverage_1.IgnoreType.If) {
                    executedLineCount[i] = branch.falseCount;
                }
                else {
                    executedLineCount[i] = -2;
                }
            }
        }
    }
    calcLineCoverage() {
        for (const fileData of this.coverage.files) {
            this.calcFileLineCoverage(fileData);
        }
    }
    calcBranchCoverage() {
        for (const fileData of this.coverage.files) {
            if (!fileData.functions) {
                continue;
            }
            let totalBranches = 0;
            let executedBranches = 0;
            fileData.functions.forEach((functionItem) => {
                if (functionItem.ignored !== coverage_1.IgnoreType.None) {
                    return;
                }
                let tempResult = this.doCalcBranches(functionItem);
                totalBranches = totalBranches + tempResult.innerTotalBranches;
                executedBranches = executedBranches + tempResult.innerExecutedBranches;
            });
            fileData.summary.branches = new coverage_1.Coverage(totalBranches, executedBranches);
            this.coverage.summary.branches.total += totalBranches;
            this.coverage.summary.branches.covered += executedBranches;
        }
    }
    doCalcBranches(functionItem) {
        let innerTotalBranches = 0;
        let innerExecutedBranches = 0;
        functionItem.branches.forEach((currentBranch) => {
            switch (currentBranch.ignored) {
                case coverage_1.IgnoreType.If:
                    if (currentBranch.group.length > 0) {
                        return;
                    }
                    innerTotalBranches++;
                    if (currentBranch.falseCount > 0) {
                        innerExecutedBranches += 1;
                    }
                    return;
                case coverage_1.IgnoreType.Else:
                    if (currentBranch.group.length > 0) {
                        return;
                    }
                    innerTotalBranches++;
                    if (currentBranch.trueCount > 0) {
                        innerExecutedBranches += 1;
                    }
                    return;
                case coverage_1.IgnoreType.None:
                    innerTotalBranches++;
                    if (currentBranch.trueCount > 0) {
                        innerExecutedBranches += 1;
                    }
                    if (currentBranch.group.length <= 0) {
                        innerTotalBranches++;
                    }
                    if (currentBranch.group.length <= 0 && currentBranch.falseCount > 0) {
                        innerExecutedBranches += 1;
                    }
                    return;
            }
        });
        return { innerTotalBranches, innerExecutedBranches };
    }
    writeJsonReport() {
        const filePath = path.join(this.output, 'coverageReport.json');
        fs.writeFile(filePath, JSON.stringify(this.coverage), (err) => {
            if (err) {
                logger.error('Error writing file:', err);
            }
            else {
                logger.info('Finished file written successfully');
            }
        });
    }
    writeHtmlReport() {
        let html = new html_1.HtmlReport(this.coverage, this.output);
        html.write();
        logger.info('Finished write html report');
    }
}
exports.Report = Report;
