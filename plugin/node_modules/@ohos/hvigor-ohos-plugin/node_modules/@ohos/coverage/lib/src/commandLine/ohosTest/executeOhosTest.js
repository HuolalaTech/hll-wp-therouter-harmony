"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeCoverageOhosTest = void 0;
const path = require("path");
const fs = require("fs");
const util = require("util");
const child_process_1 = require("child_process");
const coverageParser_1 = require("../localTest/coverageParser");
const standardErrorMessage_1 = require("../../error/standardErrorMessage");
const logRelativeDir = '.test/default/intermediates/ohosTest/coverage_data';
const logRelativePath = `${logRelativeDir}/coverage.log`;
const testNameRule = /^[A-Za-z]{1}[\w#,.]*$/;
const lineBreak = /[(\r\n)\r\n]+/;
const dumpCommand = 'shell hidumper -s 1201 -a';
async function bundleOperate(hdcPath, bundleName, dependenciesPaths, targetHapPath, testHapPath) {
    (0, child_process_1.execSync)(`${hdcPath} uninstall ${bundleName}`, { windowsHide: true });
    for (let item of dependenciesPaths) {
        if (item) {
            if (!fs.existsSync(item)) {
                throw new Error((0, standardErrorMessage_1.getFormattedErrorMsg)('PATH_DOES_NOT_EXIST').replace('{path}', item));
            }
            (0, child_process_1.execSync)(`${hdcPath} install ${item}`, { windowsHide: true });
        }
    }
    if (!fs.existsSync(targetHapPath)) {
        throw new Error((0, standardErrorMessage_1.getFormattedErrorMsg)('PATH_DOES_NOT_EXIST').replace('{path}', targetHapPath));
    }
    if (!fs.existsSync(testHapPath)) {
        throw new Error((0, standardErrorMessage_1.getFormattedErrorMsg)('PATH_DOES_NOT_EXIST').replace('{path}', testHapPath));
    }
    const utilCommand = util.promisify(child_process_1.exec);
    const { stdout, stderr } = await utilCommand(`${hdcPath} install ${targetHapPath}`);
    if (stderr) {
        throw new Error(stderr);
    }
    if (stdout.includes('error: ')) {
        throw new Error(stdout);
    }
    (0, child_process_1.execSync)(`${hdcPath} install ${testHapPath}`, { windowsHide: true });
    return true;
}
function dirOperate(modulePath, bundleName) {
    const logAbsolutePath = path.join(modulePath, logRelativePath);
    if (fs.existsSync(logAbsolutePath)) {
        fs.unlinkSync(logAbsolutePath);
    }
    let logDirectory = path.dirname(logAbsolutePath);
    if (fs.existsSync(logDirectory)) {
        let files = fs.readdirSync(logDirectory);
        for (let fileItem of files) {
            if (fileItem.startsWith(`asan-${bundleName}-`)) {
                fs.unlinkSync(path.join(logDirectory, fileItem));
            }
        }
    }
    else {
        fs.mkdirSync(logDirectory, { recursive: true });
    }
    return logAbsolutePath;
}
async function getNewAsanFile(hdcPath, bundleName, oldAsanFiles, logger) {
    let result = new Array();
    const utilCommand = util.promisify(child_process_1.exec);
    const faultlogListCommand = `${hdcPath} ${dumpCommand} "-p Faultlogger"`;
    const { stdout, stderr } = await utilCommand(faultlogListCommand);
    if (stderr) {
        logger.error(stderr);
        return result;
    }
    if (stdout.includes('error: ')) {
        logger.error(stdout);
        return result;
    }
    return stdout.split(lineBreak)
        .filter(line => line.trim().startsWith(`asan-${bundleName}-`))
        .filter(file => !oldAsanFiles.includes(file));
}
async function dumpFaultlog(hdcPath, modulePath, asanFileName, logger) {
    const utilCommand = util.promisify(child_process_1.exec);
    const dumpFaultlogCommand = `${hdcPath} ${dumpCommand} "-p Faultlogger -f ${asanFileName}" > ${modulePath}/${logRelativeDir}/${asanFileName}.log`;
    logger.debug('Saving asan log...');
    const { stdout, stderr } = await utilCommand(dumpFaultlogCommand);
    if (stderr) {
        logger.error(stderr);
    }
    if (stdout.includes('error: ')) {
        logger.error(stdout);
    }
}
/**
 *
 * @param testInstrumentParam
 */
const executeCoverageOhosTest = async (testInstrumentParam) => {
    let { toolchainsPath, projectPath, modulePath, bundleName, bundleType, coverage, logger, scope, testModuleName, targetHapPath, testHapPath, dependenciesPaths } = testInstrumentParam;
    if (scope !== '' && !testNameRule.test(scope)) {
        throw new Error((0, standardErrorMessage_1.getFormattedErrorMsg)('SCOPE_IS_INVALID').replace('{scope}', scope));
    }
    let hdcPath = toolchainsPath;
    try {
        if (process.platform === 'win32') {
            hdcPath = path.join(toolchainsPath, 'hdc.exe');
        }
        else if (process.platform === 'darwin' || process.platform === 'linux') {
            hdcPath = path.join(toolchainsPath, 'hdc');
        }
        hdcPath = `"${hdcPath}"`;
        (0, child_process_1.execSync)(`cd ${projectPath}`, { windowsHide: true });
        await bundleOperate(hdcPath, bundleName, dependenciesPaths, targetHapPath, testHapPath);
        const logAbsPath = dirOperate(modulePath, bundleName);
        const aaTestCommand = scope
            ? `${hdcPath} shell aa test -b ${bundleName} -m ${testModuleName} -s unittest /ets/testrunner/OpenHarmonyTestRunner -s class ${scope} -s timeout 15000 -s coverage ${coverage}`
            : `${hdcPath} shell aa test -b ${bundleName} -m ${testModuleName} -s unittest /ets/testrunner/OpenHarmonyTestRunner -s timeout 15000 -s coverage ${coverage}`;
        const utilCommand = util.promisify(child_process_1.exec);
        logger.debug('Execute aa test...');
        let asanFileBeforeAATest = await getNewAsanFile(hdcPath, bundleName, new Array(), logger);
        const { stdout, stderr } = await utilCommand(aaTestCommand);
        if (stdout.includes('ExecuteCommand need connect-key?')) {
            throw new Error('ExecuteCommand need connect-key?');
        }
        if (stdout.includes('error: unlock screen failed in developer mode') || stdout.includes('Error Code:10106102')) {
            throw new Error((0, standardErrorMessage_1.getFormattedErrorMsg)('NO_TEST_RESULTS'));
        }
        if (stderr) {
            throw new Error(stderr);
        }
        fs.writeFileSync(logAbsPath, stdout, { flag: 'a+' });
        let asanFileAfterAATest = await getNewAsanFile(hdcPath, bundleName, asanFileBeforeAATest, logger);
        if (asanFileAfterAATest.length > 0) {
            await dumpFaultlog(hdcPath, modulePath, asanFileAfterAATest[0], logger);
        }
        await (0, coverageParser_1.parseCoverageData)({
            modulePath: modulePath,
            projectPath: projectPath,
            hdcPath: hdcPath,
            coverage: coverage,
            logger: logger,
            isLocalTest: false,
            dependenciesPaths: dependenciesPaths,
            bundleName: bundleName,
            bundleType: bundleType
        });
    }
    catch (error) {
        throw new Error(error);
    }
};
exports.executeCoverageOhosTest = executeCoverageOhosTest;
